import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";

import JsLanguagesConfig from "!!raw-loader!./js/languagesConfig.js";

import JsGetVariantVariableKeys from "!!raw-loader!./js/getVariantVariableKeys.js";

import JsMergeTranslationConfigs from "!!raw-loader!./js/mergeTranslationConfigs.js";

Let's look at a slightly more complex example where you have to run an experiment
whilst accomodating for multiple languages.

Here, we have a languagesConfig.js file:

<CodeBlock language="js" title=".../src/languagesConfig.js">
  {JsLanguagesConfig}
</CodeBlock>

In our code, we can then get all of our variant variables using:

<CodeBlock language="js">{JsGetVariantVariableKeys}</CodeBlock>

The `translationVariations` variable would then be returned as something like:

```json
{
  "header_v1": {
    "en": "Our beautiful header!",
    "nl": "Onze mooie kop!"
  },
  "call_to_action1_v1": {
    "en": "Continue",
    "nl": "Doorgaan"
  }
}
```

...which you could then merge with your original translations, like so:

<CodeBlock language="js">{JsMergeTranslationConfigs}</CodeBlock>

...which would return an object similar to:

```js
{
    get header: () => {
      exp.treatment("experiment1");
      return {
        en: "Our beautiful header!",
        nl: "Onze mooie kop!",
      };
    }
    get call_to_action1: () => {
      exp.treatment("experiment2");
      return {
        en: "Click here!",
        nl: "Klik Hier"
      };
    }
}
```

You can now use this object to run your experiments whilst still supporting multiple
languages!
