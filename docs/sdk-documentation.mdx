---
sidebar_position: 1
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import Install from "./sdk-documentation/getting-started/install/_install.mdx";
import ImportAndInitialize from "./sdk-documentation/getting-started/import-and-initialize/_import-and-initialize.mdx";
import CreateNewContextRequest from "./sdk-documentation/getting-started/create-new-context-request/_create-new-context-request.mdx";
import SettingContextAttributes from "./sdk-documentation/getting-started/setting-context-attributes/_setting-context-attributes.mdx";

import SelectingATreatment from "./sdk-documentation/basic-usage/selecting-a-treatment/_selecting-a-treatment.mdx";
import SelectingAVariable from "./sdk-documentation/basic-usage/selecting-a-variable/_selecting-a-variable.mdx";

import Publish from "./sdk-documentation/publish/_publish.mdx";

import Finalize from "./sdk-documentation/finalize/_finalize.mdx";

import TrackingGoals from "./sdk-documentation/tracking-goals/_tracking-goals.mdx";

# SDK Documentation

This guide provides detailed information about A/B Smartly’s JavaScript SDK.

---

## Getting Started

### Install the SDK

<Install />

### Import and Initialize the SDK

<ImportAndInitialize />

### Create a New Context Request

<CreateNewContextRequest />

### Set Context Attributes

<SettingContextAttributes />

## Basic Usage

After the init call all the variants for all running experiments will be
cached in memory. The init call should take single digit milliseconds on the
server side, on the client side it may take a little longer (it’s another
roundtrip to the server), unless you pass the data directly in the HTML, which
makes it ready immediately. Any experiment that is evaluated and is not
running will return variant 0 (the control group).

To make sure the SDK is properly loaded before asking it for a treatment,
block until the SDK is ready, as shown below. `ready()` returns a promise. You
can also just check if it is ready with the `isReady()` method.

After the sdk is loaded you can use the treatment method to return the proper
treatment based on the experiment_name and the units data passed when
instantiating the SDK.

Then use an `if-else-if-else` block as shown below and insert the code for the
different treatments that you plan to create.

### Selecting a Treatment

<SelectingATreatment />

### Selecting a Treatment Variable

<SelectingAVariable />

## Config API

:::danger
Only available for JS-SDK
:::

If you use configuration files to change different aspects of your application, then you are better served with the config API.
Experiment configuration values are actually meant to be used with the config API.
When the config API is used you don't need to call the treatment() method. It will be called automatically when keys from the config are used.

```js
// Import the mergeConfig function.
import { mergeConfig } from "@absmartly/javascript-sdk";

/*

Your current config might be something like:

const myAppConfig = { ... };

or

const myAppConfig = getConfigFromFile(config.json);

then you just need to add the mergeConfig function like this:
*/

const myAppConfig = mergeConfig(getConfigFromFile(config.json));
```

Let's say you use a configuration file to change some parameters in your application:

```js
let cfg = {
    button: {
        color: "blue",
        cta: "Click me",
    },
    hero_image: "http://cdn.com/img1.png",
    some_other_stuff: { ... },
};
```

Then you could use the config API to run experiments that change those parameters.

When starting one experiment you can assign variables to each variant. Let's say you start experiment1 with button.color: "blue" in the control group and button.color: "green" in the variant, and experiment2 with button.cta set to "Click here" and "Click me" and hero_image set to 2 different urls.
For each user the SDK would receive a payload similar to this:

```json
{
  "guid": "dhsUiLJ7xgQBEbivw_0cjiKo9O6UlnSg",
  "units": [],
  "assignments": [
    {
      "name": "experiment1",
      "variant": 1,
      "config": {
        "button.color": "green"
      }
    },
    {
      "name": "experiment2",
      "variant": 0,
      "config": {
        "button.cta": "Click here",
        "hero_image": "http://cdn.com/img1.png"
      }
    }
  ]
}
```

This user is in variant 1 of the first experiment and in the control group for the second one. Calling exp.mergeConfig(cfg) from the Javascript SDK would return a config object like this:

```json
{
    button: {
        get color: () => { exp.treatment("experiment1"); return "green"; },
        get cta: () => { exp.treatment("experiment2"); return "Click here"; },
    }
    get hero_image: () => { exp.treatment("experiment2"); return "http://cdn.com/img1.png"; },
    some_other_stuff: { ... },
}
```

So you can continue using the configuration as you were using it before, but now the right experiments will be triggered when a value is used and that value was overridden by one experiment.

This greatly simplifies setting up experiments and cleaning up the code. If at some point a big part of the code is configured like this you can set up different experiments without touching one line of code.

## Translations Example

:::danger
Only available for JS-SDK
:::

```js
let translations = {
    header1: { en: "Our nice header!", nl: "Onze leuk kop!" },
    call_to_action1: { en: "Click here!", ... },
};

// And then somewhere after the SDK initialization
const newTagsToFetch = context.variableKeys();

const translationVariations = fetchTranslations(newTagsToFetch);
/*
{
    header1_v1: { en: "Our beautiful header!", nl: "Onze mooie kop!" },
    call_to_action1_v1: { en: "Continue", ... },
}
*/

translations = mergeConfig(translations, translationVariations);
/*
{
    get header1: () => {
      exp.treatment("experiment1");
      return {
        en: "Our beautiful header!",
        nl: "Onze mooie kop!",
      };
    }
    get call_to_action1: () => {
      exp.treatment("experiment2");
      return {
        en: "Click here!",
        ...
      };
    }
}
*/
```

## Publish

<Publish />

## Finalize

<Finalize />

## Attributes

:::danger
Possibly just a repeat of **Create a New Context Request**
:::

To create audiences (target based on specific conditions) you need to pass custom attributes to the SDK, before making the exp.treatment call. This can be done using the method exp.attributes or by passing an attributes parameter in the SDK initialization. It’s common to use a mix of both methods. Many attributes of the user and/or request are known from the beginning and can be passed at initialization, others may depend on information only known later in the request.

The attributes are compared and evaluated against the attributes used in the Web console to verify that the right conditions were added to the code.
If the SDK fails to match the conditions in the code with the conditions used in the Web console, users with a mismatch will still be exposed to the experiment unless enforce_audiences: true is passed to the SDK at initialization. Otherwise you’ll see a warning in the console to let you know that the conditions in the code don’t match the audience that you were planning to target.
In the example below, we are rolling out an experiment to users that are logged in, using the website in English, bought an item with a price greater than $100 and are a returning customer.

```js
exp.attributes({
  // date attributes are handled as millis since epoch
  created: new Date('YYYY-MM-DDTHH:mm:ss.sssZ').getTime(),
  language: user.language, // 'en'
  price: item.price, // 10000
  authenticated: user.isAuthenticated, // true
  groups: user.groups, // [ 'returning', 'frequent_buyer' ]
};

if (user.language === 'en'
  && user.isAuthenticated()
  && item.price >= 10000 // price in cents
  && user.groups.some(e => e === 'returning'),
  && exp.treatment('exp_name')) {
   // insert treatment code here
} else {
   // insert control code here
}
```

:::caution
You should create an audience with the exact same attributes in the Web console. By default it will not enforce those conditions, but if for some reason the exp.treatment method is called for a user that doesn’t meet this criteria, the Web console will warn you about it. This means that you either didn’t specify your audience correctly in the Web console, or you have a bug in your triggering condition.
:::

## Tracking Goals

Use the track method to record any actions your customers perform. Each action is known as a goal and corresponds to a goal_name. Calling track through the SDKs is the easiest way of getting experimentation data into A/B Smartly and allows you to measure the impact of your experiments on your users' actions and metrics.
Other ways to track goals is to use the Segment.io integration or using enrichments to consume them from other event streams and/or databases.
In the examples below you can see that the track() method can take up to two arguments. The proper data type and syntax for each are:

- **goal_name**: The traffic type of the key in the track call. The expected data type is String. You should only pass values that match the names of goals that you have defined in the Web console, everything else will be ignored.
- **properties** (Optional): An object of key value pairs that can be used to create extra metrics or to filter the goal.

<TrackingGoals />
